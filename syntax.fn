finch:
-----



a < b then: { obj someMessage }

a < b then: { obj someMessage.
               obj anotherMessage }

a < b then: |{ it someMessage.
                   obj anotherMessage }

a < b then: | arg { arg someMessage.
                   obj anotherMessage }

// blocks:
no args:  { obj someMessage }
one arg:  | arg { arg someMessage }
          |{ it someMessage } // implicit arg name "it"
two args: | first second { first gets: second }

// compound expressions:
obj first . obj second

// answer:
return resultObject

// assignment:
set variable value

// cascade:
foo bar, bang, baz

// set data slot
someObj slotName: 123

// get data slot
someObj slotName

local variables:
|temp anotherTemp|


smalltalk:
---------

messages:
unary:   obj message
binary:  obj + other
keyword: obj send: a and: b and: c

blocks:
no args:  [obj someMessage]
one arg:  [:arg| arg someMessage]
two args: [:first :second| first gets: second]

compound expressions:
obj first . obj second

answer:
^resultObject

assignment:
variable := value

cascade:
foo bar; bang; baz

local variables:
|temp anotherTemp|

method definition:
SomeClass>>methodName
    obj message.
    ^answer

SomeClass>>+ operand
    instanceVariable := instanceVariable + operand.
    ^self

SomeClass>>keyword: object message: text
    Transcript nextPut: object; nextPut: ' ';
               nextPutAll: text;
               cr.
