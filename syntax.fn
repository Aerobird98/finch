finch:
-----

// symbol
_symbolName

// blocks:
no args:  { obj someMessage }
one arg:  {|arg| someMessage }
          {|| it someMessage } // implicit arg name "it"
two args: {|first second| first gets: second }

// compound expressions:
obj first ; obj second

// answer:
return resultObject

// assignment:
variable <- value
// note that this is only valid for variables already declared
// this is also not how fields (instance variables) are set, those
// use message sends: myObj someField: newValue

// cascade:
foo bar, bang, baz // same as foo bar; foo bang; foo baz

// define data slot (basically creates set and get messages)
someObj addField: _fieldName
someObj addField: _fieldName value: 1234

// define unary message
method someObj messageName
(   messageBody expression + 2 // () is not needed, can be single expr
    another Expression)

// define operator
method someObj ++ arg (this + arg)

// define keyword method
method someObj do: arg with: other (arg + other)
       // ^- this should be an expression that evals to an obj
       // in that case, how do we know when the expression ends and
       // the method name begins?

// define parent slot?

// set data slot
someObj slotName: 123 // not the same as defining a slot

// get data slot
someObj slotName

// local variables
def temp 123 // defines a new local at this scope

set temp 123 // sets the value of 'temp' at whatever scope it was
             // previously defined. use this to change variables
             // defined in outer scopes
             
unset temp // remove a previously defined variable at this scope
// note this is different from setting temp to Nil
// when you unset a variable, you unshadow that name
// from being accessible in a parent scope. consider:
{
    def a 1
    
    // set to nil
    {
        def a 2
        set a Nil
        Out write: a // writes 'nil'
    }
    
    // unset
    {
        def a 2
        unset a
        Out write: a // writes 1
    }
}

// global variables
def SomeGlobal // case distinguishes global from local

smalltalk:
---------

messages:
unary:   obj message
binary:  obj + other
keyword: obj send: a and: b and: c

blocks:
no args:  [obj someMessage]
one arg:  [:arg| arg someMessage]
two args: [:first :second| first gets: second]

compound expressions:
obj first . obj second

answer:
^resultObject

assignment:
variable := value

cascade:
foo bar; bang; baz

local variables:
|temp anotherTemp|

method definition:
SomeClass>>methodName
    obj message.
    ^answer

SomeClass>>+ operand
    instanceVariable := instanceVariable + operand.
    ^self

SomeClass>>keyword: object message: text
    Transcript nextPut: object; nextPut: ' ';
               nextPutAll: text;
               cr.
