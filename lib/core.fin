def Object {
  // By default, just check reference equality.
  == right { self === right }

  != right { (self == right).not }

  && right { self.if-true { right } else { self } }

  // Any non-true object is implicitly "false", so sending "not" to it
  // returns true.
  not { true }

  // type tests
  array?   { false }
  block?   { false }
  boolean? { false }
  fiber?   { false }
  number?  { false }
  string?  { false }

  if-true(then) else(else) { else.call }

  // calling a non-block like a block just returns the value
  call { self }
  call(a) { self }
  call(a, b) { self }
  call(a, b, c) { self }
  call(a, b, c, d) { self }
  call(a, b, c, d, e) { self }
  call(a, b, c, d, e, f) { self }
  call(a, b, c, d, e, f, g) { self }
  call(a, b, c, d, e, f, g, h) { self }
  call(a, b, c, d, e, f, g, h, i) { self }
  call(a, b, c, d, e, f, g, h, i, j) { self }

  yourself { self }
}

def true {
  not { false }
  boolean? { true }
  to-string { "true" }
  if-true(then) else(else) { then.call }
}

def false {
  boolean? { true }
  to-string { "false" }
}

def Ether {
  from(start) to(end) step(step) do(block) {
    var i = start

    while { i <= end } do {
      block.call(i)
      i = i + step
    }
  }

  from(start) to(end) do(block) {
    var step = if (start <= end) then (1) else (-1)
    from (start) to (end) step (step) do (block)
  }

  do(block) { block.call }

  if(condition) then(then) { condition.if-true(then) else { nil } }
  if(condition) then(then) else(else) { condition.if-true(then) else(else) }

  if(if1) then(then1) else-if(if2) then(then2) else(else) {
    if(if1) then(then1) else {
      if(if2) then(then2) else(else)
    }
  }

  loop(block) {
    while(true) do(block)
  }

  while(condition) do(block) {
    if(condition.call) then {
      block.call
      while(condition) do(block)
    }
  }

  while(condition-a) and(condition-b) do(block) {
    while { condition-a.call.and(condition-b) } do(block)
  }

  until(condition) do(block) {
    while { condition.call.not } do(block)
  }

  // Build the output methods in terms of the single primitive one.
  write(text) {
    // Make sure the argument is always converted to a string before
    // passing to the primitive version which can't do that.
    *primitive*.write(text.to-string)
  }

  write-line(text) {
    // Make sure the argument is always converted to a string before
    // passing to the primitive version which can't do that.
    *primitive*.write(text.to-string)
    *primitive*.write("\n")
  }
}

def Blocks {
  block? { true }
}

obj Fiber {
  new(block) { *primitive*.new-fiber(block) }

  spawn(block) {
    var fiber = Fiber.new(block)
    // Immediately run it, discarding the first yielded result.
    fiber.run
    fiber
  }

  current { *primitive*.current-fiber }

  yield(value) {
    *primitive*.switch-to-fiber(Fiber.current.run-by) passing(value)
  }

  yield { Fiber.yield(nil) }
}

def Fibers {
  fiber? { true }

  run(value) {
    _run-by = Fiber.current
    *primitive*.switch-to-fiber(self) passing(value)
  }

  run { self.run(nil) }
  run-by { _run-by }
}

def Numbers {
  number? { true }

  // Double-dispatch.
  + right { right.number+(self) }
  - right { right.number-(self) }
  * right { right.number*(self) }
  / right { right.number/(self) }
  == right { right.number==(self) }
}

def Object {
  // Adding anything to a string converts it to a string and concatenates.
  string+(left) { *primitive*.string-concat(left, self.to-string) }

  // Comparisons between unrelated types always return false.
  number==(left) { false }
  string==(left) { false }
}

def Strings {
  string? { true }

  // Adding a number to a string converts it to a string and concatenates.
  number+(left) { left.to-string + self }

  // Double-dispatch.
  + right { right.string+(self) }
  == right { right.string==(self) }

  string==(left) { (*primitive*.string-compare(left, self)) == 0 }
  < right { (*primitive*.string-compare(self, right)) < 0 }
  > right { (*primitive*.string-compare(self, right)) > 0 }
  <= right { (*primitive*.string-compare(self, right)) <= 0 }
  >= right { (*primitive*.string-compare(self, right)) >= 0 }

  starts-with(needle) { self.index-of(needle) == 0 }

  contains(needle) { self.index-of(needle) != -1 }

  from(from) { self.from(from) count(self.count - from) }
  from(from) to(to) { self.from(from) count(to - from) }
}

obj Array {
  count(count) {
    self.count(count) fill-with(nil)
  }

  count(count) fill-with(element) {
    var result = []

    from (1) to (count) do { i -> result.add(element) }
    result
  }
}

def Arrays {
  array? { true }

  ++ right {
    var result = []

    self.each { result.add(_) }
    right.each { result.add(_) }

    result
  }

  each(block) {
    from (0) to (self.count - 1) do { block.call(self.at(_)) }
  }

  each(block) between(between) {
    var first = true
    from (0) to (self.count - 1) do { i ->
      if (first.not) then (between)
      first = false
      block.call(self.at(i))
    }
  }

  map(block) {
    var result = []
    self.each { result.add(block.call(_)) }
    result
  }
}

// Truthiness: only two things are true: the true object, and blocks that
// evaluate to it.
def Object {
  true? { false }
}

def true {
  true? { true }
}

def Blocks {
  true? { self.call.true? }
}

// Short-circuiting logical operators
def Object {
  and(right) {
    if (self.true?) then {
      right.true?
    } else {
      false
    }
  }

  or(right) {
    if (self.true?) then {
      true
    } else {
      right.true?
    }
  }
}

// TODO(bob): Cascades are broken right now, so no switch.
/*
// switch/case construct. usage looks like:
// c.switch \
//     .case("{") do { "foo" } ;
//     .case("}") do { "blah" } ;
//     .default { "argh" }
def Object {
  switch {
    // ### bob: having to do this is lame. :(
    var outer-self = self
    [|Switches|
      _value  = outer-self
      _done?  = false
      _result = nil
    ]
  }
}

var Switches = [
  case (case) do(block) {
    // If this switch has already matched a case, just do nothing.
    if(_done?.not) then {
      // If the case is a block, then it's a predicate so evaluate
      // it, otherwise it's a value, so compare it to the value being
      // switched.
      var matched = if(case.block?) then {
        case.call(_value)
      } else {
        _value == case
      }

      if(matched) then {
        // Execute the block.
        _result = block.call(_value)
        _done? = true
      }
    }

    // Always return the result. If we haven't matched yet, this will
    // just be nil. Once we've matched, it will be the matched value.
    _result
  }

  default(block) {
    // If this switch has already matched a case, just do nothing.
    if(_done?.not) then {
      // Execute the block.
      _result = block.call(_value)
      _done? = true
    }

    _result
  }
]
*/

// ###bob: temp; run tests
//load("test/test.fin")
