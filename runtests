#!/usr/bin/python

# Runs the language tests.
from collections import defaultdict
from os import listdir
from os.path import abspath, dirname, isdir, isfile, join, realpath, relpath, splitext
import re
from subprocess import Popen, PIPE
import sys
from string import strip

FINCH_DIR = dirname(realpath(__file__))
TEST_DIR = join(FINCH_DIR, 'test')

if sys.platform == 'win32':
    FINCH_DIR = join(FINCH_DIR, 'Debug', 'finch.exe')
    if not isfile(FINCH_DIR):
        FINCH_APP = join(FINCH_DIR, 'Release', 'finch.exe')
    if not isfile(FINCH_APP):
        sys.exit('Cannot find finch.exe!')
elif sys.platform.startswith('linux'):
    FINCH_APP = join(FINCH_DIR, '1', 'out', 'Debug', 'finch')
    if not isfile(FINCH_APP):
        FINCH_APP = join(FINCH_DIR, '1', 'out', 'Release', 'finch')
    if not isfile(FINCH_APP):
        sys.exit('Cannot find finch!')
elif sys.platform.startswith('darwin'):
    FINCH_APP = join(FINCH_DIR, 'build', 'Debug', 'finch')
    if not isfile(FINCH_APP):
        FINCH_APP = join(FINCH_DIR, 'build', 'Release', 'finch')
    if not isfile(FINCH_APP):
        sys.exit('Cannot find finch!')
else:
    sys.exit('System not supported!')

SKIP_PATTERN = re.compile(r'// skip: (.*)')
NONTEST_PATTERN = re.compile(r'// nontest')
FAIL_PATTERN = re.compile(r'FAIL (.*)')

passed = 0
failed = 0
skipped = defaultdict(int)
num_skipped = 0;

if sys.platform == 'win32':
    class color:
        GREEN = ''
        RED = ''
        DEFAULT = ''
        PINK = ''
        YELLOW = ''
else:
    class color:
        GREEN = '\033[32m'
        RED = '\033[31m'
        DEFAULT = '\033[0m'
        PINK = '\033[91m'
        YELLOW = '\033[33m'

def print_line(line=None):
    # Erase the line.
    print '\033[2K',
    # Move the cursor to the beginning.
    print '\r',
    if line:
        print line,
        sys.stdout.flush()

def walk(dir, callback):
    """ Walks [dir], and executes [callback] on each file. """
    dir = abspath(dir)
    for file in [file for file in listdir(dir) if not file in [".",".."]]:
        nfile = join(dir, file)
        if isdir(nfile):
            walk(nfile, callback)
        else:
            callback(nfile)

def run_test(path):
    global passed
    global failed
    global skipped
    global num_skipped

    if (splitext(path)[1] != '.fin'):
        return

    # Check if we are just running a subset of the tests.
    if len(sys.argv) == 2:
        this_test = relpath(path, join(FINCH_DIR, 'test'))
        if not this_test.startswith(sys.argv[1]):
            return

    # Make a nice short path relative to the working directory.
    path = relpath(path)

    # Read the test and parse out the expectations.
    expect_output = []
    expect_error = []
    expect_return = 0

    print_line('Passed: ' + color.GREEN + str(passed) + color.DEFAULT +
               ' Failed: ' + color.RED + str(failed) + color.DEFAULT +
               ' Skipped: ' + color.YELLOW + str(num_skipped) + color.DEFAULT)

    with open(path, 'r') as file:
        for line in file:
            match = SKIP_PATTERN.search(line)
            if match:
                num_skipped += 1
                skipped[match.group(1)] += 1
                return

            match = NONTEST_PATTERN.search(line)
            if match:
                # Not a test file at all, so ignore it.
                return

    # Invoke finch and run the test.
    proc = Popen([FINCH_APP, path], stdout=PIPE, stderr=PIPE)
    (out, err) = proc.communicate()
    (out, err) = out.replace('\r\n', '\n'),  err.replace('\r\n', '\n')

    fails = []

    # Validate the exit code.
    if proc.returncode != 0:
        fails.append('Expected return code 0 and got {1}.'.
            format(proc.returncode))
    else:
        # Validate that no test failures occurred.
        lines = out.split('\n')
        while len(lines) > 0:
            line = lines.pop(0)
            match = FAIL_PATTERN.search(line)
            if match:
                fails.append(match.group(1))

    # Display the results.
    if len(fails) == 0:
        passed += 1
        #print color.GREEN + 'PASS' + color.DEFAULT + ': ' + path
    else:
        failed += 1
        print_line(color.RED + 'FAIL' + color.DEFAULT + ': ' + path)
        print
        for fail in fails:
            print '     ', color.PINK + fail + color.DEFAULT
        print

walk(TEST_DIR, run_test)

print_line()
if failed == 0:
    print 'All ' + color.GREEN + str(passed) + color.DEFAULT + ' tests passed.'
else:
    print (color.GREEN + str(passed) + color.DEFAULT + ' tests passed. ' +
           color.RED + str(failed) + color.DEFAULT + ' tests failed.')

for key in sorted(skipped.keys()):
    print ('Skipped ' + color.YELLOW + str(skipped[key]) + color.DEFAULT +
           ' tests: ' + key)
