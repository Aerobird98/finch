aa
// a comment
//  
finch:
-----

symbols:
  `symbolName

blocks:
  no args:  { obj someMessage }
  one arg:  {|arg| someMessage }
            {|| it someMessage } // implicit arg name "it"
  two args: {|first second| first gets: second }

compound expressions:
  obj first; obj second

early return:
  return resultObject

cascade:
  foo bar, bang, baz // same as foo bar; foo bang; foo baz

define data slot (basically creates set and get messages):
  someObj addField: `fieldName
  someObj addField: `fieldName value: 1234

define unary message:
  //bob: temp
  method someObj messageName
  (   messageBody expression + 2 // () is not needed, can be single expr
      another Expression)

define operator:
  //bob: temp
  method someObj ++ arg (this + arg)

define keyword method:
  //bob: temp
  method someObj do: arg with: other (arg + other)
         // ^- this should be an expression that evals to an obj
         // in that case, how do we know when the expression ends and
         // the method name begins?

define prototype slot:
  someObj prototype: thePrototype

set data slot:
  someObj slotName: 123 // not the same as defining a slot

get data slot:
  someObj slotName

local variables:
def temp 123 // defines a new local at this scope

set temp 123 // sets the value of 'temp' at whatever scope it was
             // previously defined. use this to change variables
             // defined in outer scopes
             
unset temp // remove a previously defined variable at this scope
// note this is different from setting temp to Nil
// when you unset a variable, you unshadow that name
// from being accessible in a parent scope. consider:
{
    def a 1
    
    // set to nil
    {
        def a 2
        set a Nil
        Out write: a // writes 'nil'
    }
    
    // unset
    {
        def a 2
        unset a
        Out write: a // writes 1
    }
}

global variables:
def SomeGlobal // case distinguishes global from local
