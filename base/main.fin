True :: not { False }

' define a for-style loop
Ether :: from: start to: end step: step do: block {
    i <- start
    
    while: { i <= end } do: {
        block call: i
        i <-- i + step
    }
}

Ether :: from: start to: end do: block {
    from: start to: end step: 1 do: block
}

' a chained if/then/else
Ether :: if: if1 then: then1 elseif: if2 then: then2 else: else {
    if: if1 then: then1 else: {
        if: if2 then: then2 else: else
    }
}

' object
Object <- Prims** objectPrototype copy

' access the object prototype object
Object :: prototype { Prims** objectPrototype }

' any non-true object is implicitly "false", so sending "not" to it
' returns true
Object prototype :: not { True }

' block
Block <- Object prototype copy

' access the object prototype object
Block :: prototype { Prims** blockPrototype }

' number
Number <- Object prototype copy

Number :: prototype { Prims** numberPrototype }

' string
String <- Object prototype copy

String :: prototype { Prims** stringPrototype }

' array
Array <- Object prototype copy

' access the array prototype object
Array :: prototype { Prims** arrayPrototype }

' constructors
Array :: count: count {
    self count: count fillWith: Nil
}

Array :: count: count fillWith: element {
    result <- []

    from: 1 to: count do: {|i| result add: element }
    result
}

' instance methods

' concatenate two arrays
Array prototype :: ++ right {
    result <- []
    
    self each: {|e| result add: e }
    right each: {|e| result add: e }
    
    result
}

Array prototype :: each: block {
    from: 0 to: self length - 1 do: {|i|
        block call: (self at: i)
    }
}

Array prototype :: map: block {
    result <- []
    self each: {|element| result add: (block call: element) }
    result
}

writeLine: "Base library loaded."