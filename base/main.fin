True addMethod: "not" body: { False }

' define a for-style loop
Ether addMethod: "from:to:step:do:" body: {
    |start end step block|
    i <- start
    
    while: { i <= end } do: {
        block call: i
        i <-- i + step
    }
}

Ether addMethod: "from:to:do:" body: {
    |start end block|
    from: start to: end step: 1 do: block
}

' a chained if/then/else
Ether addMethod: "if:then:elseif:then:else:" body: {
    |if1 then1 if2 then2 else|
    if: if1 then: then1 else: {
        if: if2 then: then2 else: else
    }
}

' object
Object <- Prims** objectPrototype copy

' access the object prototype object
Object addMethod: "prototype" body: {
    Prims** objectPrototype
}

' any non-true object is implicitly "false", so sending "not" to it
' returns true
Object prototype addMethod: "not" body: {
    True
}

' block
Block <- Object prototype copy

' access the object prototype object
Block addMethod: "prototype" body: {
    Prims** blockPrototype
}

' number
Number <- Object prototype copy

Number addMethod: "prototype" body: {
    Prims** numberPrototype
}

' string
String <- Object prototype copy

String addMethod: "prototype" body: {
    Prims** stringPrototype
}

' array
Array <- Object prototype copy

' access the array prototype object
Array addMethod: "prototype" body: {
    Prims** arrayPrototype
}

' constructors
Array addMethod: "count:" body: {
    |count|
    self count: count fillWith: Nil
}

Array addMethod: "count:fillWith:" body: {
    |count element|
    result <- []

    from: 1 to: count do: {|i| result add: element }
    result
}

' instance methods
Array prototype addMethod: "each:" body: {|block|
    from: 0 to: self length - 1 do: {|i|
        block call: (self at: i)
    }
}

Array prototype addMethod: "map:" body: {|block|
    result <- []
    self each: {|element| result add: (block call: element) }
    result
}

writeLine: "Base library loaded."