True :: not { False }

' define a for-style loop
Ether :: from: start to: end step: step do: block {
    i <- start
    
    while: { i <= end } do: {
        block call: i
        i <-- i + step
    }
}

Ether :: from: start to: end do: block {
    step <- (if: start < end then: 1 else: -1)
    from: start to: end step: step do: block
}

' a chained if/then/else
Ether :: if: if1 then: then1 elseif: if2 then: then2 else: else {
    if: if1 then: then1 else: {
        if: if2 then: then2 else: else
    }
}

' object
Object <- Prims** objectPrototype copy

' access the object prototype object
Object :: prototype { Prims** objectPrototype }

' any non-true object is implicitly "false", so sending "not" to it
' returns true
Object prototype :: not { True }

' logical operators
Object prototype :: and: right {
    ' ### bob: should check if self and right are blocks and handl
    ' short-circuiting
    if: self then: right else: False
}

Object prototype :: or: right {
    ' ### bob: should check if self and right are blocks and handl
    ' short-circuiting
    if: self then: True else: right
}

' block
Block <- Object prototype copy

Block :: prototype { Prims** blockPrototype }

' fiber
Fiber <- Object prototype copy

Fiber :: prototype { Prims** fiberPrototype }
Fiber :: yield: value { Prims** fiberYield: value }
Fiber :: yield { Prims** fiberYield: Nil }

Fiber prototype :: run { self run: Nil }

Fiber :: new: block { Prims** newFiber: block }

Fiber :: spawn: block {
    fiber <- Fiber new: block
    ' immediately run it, discarding the first yielded result
    fiber run
    fiber
}

' number
Number <- Object prototype copy

Number :: prototype { Prims** numberPrototype }

' string
String <- Object prototype copy

String :: prototype { Prims** stringPrototype }

' array
Array <- Object prototype copy

Array :: prototype { Prims** arrayPrototype }

Array :: count: count {
    self count: count fillWith: Nil
}

Array :: count: count fillWith: element {
    result <- []
    
    from: 1 to: count do: {|i| result add: element }
    result
}

Array prototype :: ++ right {
    result <- []
    
    self each: {|e| result add: e }
    right each: {|e| result add: e }
    
    result
}

Array prototype :: each: block {
    from: 0 to: self length - 1 do: {|i|
        block call: (self at: i)
    }
}

Array prototype :: map: block {
    result <- []
    self each: {|element| result add: (block call: element) }
    result
}

writeLine: "Base library loaded."