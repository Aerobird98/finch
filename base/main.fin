True :: not { False }

True :: boolean? { True }
False :: boolean? { True }

' define a for-style loop
Ether :: from: start to: end step: step do: block {
    i <- start
    
    while: { i <= end } do: {
        block call: i
        i <-- i + step
    }
}

Ether :: from: start to: end do: block {
    step <- (if: start < end then: 1 else: -1)
    from: start to: end step: step do: block
}

' a chained if/then/else
Ether :: if: if1 then: then1 elseif: if2 then: then2 else: else {
    if: if1 then: then1 else: {
        if: if2 then: then2 else: else
    }
}

' build the output methods in terms of the single primitive one
Ether :: write: text {
    ' make sure the argument is always converted to a string before
    ' passing to the primitive version which can't do that.
    #PRIM# write: text toString
}

Ether :: writeLine: text {
    ' make sure the argument is always converted to a string before
    ' passing to the primitive version which can't do that.
    #PRIM# write: text toString + "\n"
}

' object
Object <- #PRIM# objectPrototype copy

' access the object prototype object
Object :: prototype { #PRIM# objectPrototype }

Object prototype :: != right {
    (self = right) not
}

Object :: new {
    Object prototype copy
}

' any non-true object is implicitly "false", so sending "not" to it
' returns true
Object prototype :: not { True }

' type tests
Object prototype :: array? { False }
Object prototype :: block? { False }
Object prototype :: boolean? { False }
Object prototype :: fiber? { False }
Object prototype :: number? { False }
Object prototype :: string? { False }

' logical operators
Object prototype :: and: right {
    ' ### bob: should check if self and right are blocks and handl
    ' short-circuiting
    if: self then: right else: False
}

Object prototype :: or: right {
    ' ### bob: should check if self and right are blocks and handl
    ' short-circuiting
    if: self then: True else: right
}

' block
Block <- Object new

Block :: prototype { #PRIM# blockPrototype }

Block prototype :: block? { True }

' fiber
Fiber <- Object new

Fiber :: prototype { #PRIM# fiberPrototype }
Fiber :: yield: value { #PRIM# fiberYield: value }
Fiber :: yield { #PRIM# fiberYield: Nil }

Fiber prototype :: fiber? { True }

Fiber prototype :: run { self run: Nil }

Fiber :: new: block { #PRIM# newFiber: block }

Fiber :: spawn: block {
    fiber <- Fiber new: block
    ' immediately run it, discarding the first yielded result
    fiber run
    fiber
}

' number
Number <- Object new

Number :: prototype { #PRIM# numberPrototype }

Number prototype :: number? { True }

' string
String <- Object new

String :: prototype { #PRIM# stringPrototype }

String prototype :: string? { True }

String prototype :: + right {
    #PRIM# stringConcat: self toString and: right toString
}

String prototype :: = right {
    (#PRIM# stringCompare: self to: right) = 0
}

String prototype :: != right {
    (self = right) not
}

String prototype :: < right {
    (#PRIM# stringCompare: self to: right) < 0
}

String prototype :: > right {
    (#PRIM# stringCompare: self to: right) > 0
}

String prototype :: <= right {
    (#PRIM# stringCompare: self to: right) <= 0
}

String prototype :: >= right {
    (#PRIM# stringCompare: self to: right) >= 0
}

' array
Array <- Object new

Array :: prototype { #PRIM# arrayPrototype }

Array :: count: count {
    self count: count fillWith: Nil
}

Array :: count: count fillWith: element {
    result <- []
    
    from: 1 to: count do: {|i| result add: element }
    result
}

Array prototype :: array? { True }

Array prototype :: ++ right {
    result <- []
    
    self each: {|e| result add: e }
    right each: {|e| result add: e }
    
    result
}

Array prototype :: each: block {
    from: 0 to: self length - 1 do: {|i|
        block call: (self at: i)
    }
}

Array prototype :: map: block {
    result <- []
    self each: {|element| result add: (block call: element) }
    result
}

writeLine: "Base library loaded."

' ###bob: temp, run tests
load: "../../test/test.fin"
