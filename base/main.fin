' object
Object <- #PRIM# copy: #PRIM# objectPrototype

Object :: (
    ' access the object prototype object
    prototype { #PRIM# objectPrototype }

    new { Object prototype copy }
    new: block { Object prototype copyWith: block }
)

Object prototype :: (
    copy {
      #PRIM# copy: self
    }

    copyWith: block {
      copy <- #PRIM# copy: self
      #PRIM# run: block within: copy
      copy
    }

    != right {
        (self = right) not
    }

    ' any non-true object is implicitly "false", so sending "not" to it
    ' returns true
    not { True }

    ' type tests
    array?   { False }
    block?   { False }
    boolean? { False }
    fiber?   { False }
    number?  { False }
    string?  { False }

    ifTrue: then else: else { else call }

    ' calling a non-block like a block just returns the value
    call { self }
    call: a { self }
    call: a : b { self }
    call: a : b : c { self }
    call: a : b : c : d { self }
    call: a : b : c : d : e { self }
    call: a : b : c : d : e : f { self }
    call: a : b : c : d : e : f { self }
    call: a : b : c : d : e : f : g { self }
    call: a : b : c : d : e : f : g : h { self }
    call: a : b : c : d : e : f : g : h : i { self }
    call: a : b : c : d : e : f : g : h : i : j { self }
)

True :: not { False }

True :: boolean? { True }
False :: boolean? { True }

True :: toString { "true" }
False :: toString { "false" }

True :: ifTrue: then else: else { then call }

' define a for-style loop
Ether :: (
    from: start to: end step: step do: block {
        i <- start

        while: { i <= end } do: {
            block call: i
            i <-- i + step
        }
    }

    from: start to: end do: block {
        step <- (if: start < end then: 1 else: -1)
        from: start to: end step: step do: block
    }

    ' do
    do: block { block call }

    ' if then
    if: condition then: then { condition ifTrue: then else: { Nil } }
    if: condition then: then else: else { condition ifTrue: then else: else }

    ' a chained if/then/else
    if: if1 then: then1 elseif: if2 then: then2 else: else {
        if: if1 then: then1 else: {
            if: if2 then: then2 else: else
        }
    }

    ' while
    while: condition do: block {
        if: condition call then: {
            block call
            while: condition do: block
        }
    }

    ' build the output methods in terms of the single primitive one
    write: text {
        ' make sure the argument is always converted to a string before
        ' passing to the primitive version which can't do that.
        #PRIM# write: text toString
    }

    writeLine: text {
        ' make sure the argument is always converted to a string before
        ' passing to the primitive version which can't do that.
        #PRIM# write: text toString + "\n"
    }
)

' block
Block <- Object new

Block :: prototype { #PRIM# blockPrototype }

Block prototype :: block? { True }

' fiber
Fiber <- Object new

Fiber :: (
    new: block { #PRIM# newFiber: block }

    spawn: block {
        fiber <- Fiber new: block
        ' immediately run it, discarding the first yielded result
        fiber run
        fiber
    }

    current { #PRIM# currentFiber }

    yield: value {
      #PRIM# switchToFiber: Fiber current runBy passing: value
    }

    yield { Fiber yield: Nil }

    prototype { #PRIM# fiberPrototype }
)

Fiber prototype :: (
    fiber? { True }

    run: value {
      _runBy <- Fiber current
      #PRIM# switchToFiber: self passing: value
    }

    run { self run: Nil }
    runBy { _runBy }
)

' number
Number <- Object new

Number :: prototype { #PRIM# numberPrototype }

Number prototype :: number? { True }

' string
String <- Object new

String :: prototype { #PRIM# stringPrototype }

String prototype :: (
    string? { True }

    + right { #PRIM# stringConcat: self toString and: right toString }

    = right { (#PRIM# stringCompare: self to: right) = 0 }

    <  right { (#PRIM# stringCompare: self to: right) < 0 }
    >  right { (#PRIM# stringCompare: self to: right) > 0 }
    <= right { (#PRIM# stringCompare: self to: right) <= 0 }
    >= right { (#PRIM# stringCompare: self to: right) >= 0 }
)

' array
Array <- Object new

Array :: (
    prototype { #PRIM# arrayPrototype }

    count: count {
        self count: count fillWith: Nil
    }

    count: count fillWith: element {
        result <- []

        from: 1 to: count do: {|i| result add: element }
        result
    }
)

Array prototype :: (
    array? { True }

    ++ right {
        result <- []

        self each: {|e| result add: e }
        right each: {|e| result add: e }

        result
    }

    each: block {
        from: 0 to: self length - 1 do: {|i|
            block call: (self at: i)
        }
    }

    map: block {
        result <- []
        self each: {|element| result add: (block call: element) }
        result
    }
)

' truthiness: only two things are true: the True global object, and
' blocks that evaluate to it.
Object prototype :: true? { False }
True :: true? { True }

Block prototype :: true? { self call true? }

' logical operators
Object prototype :: (
    and: right {
        if: self true? then: {
            right true?
        } else: {
            False
        }
    }

    or: right {
        if: self true? then: {
            True
        } else: {
            right true?
        }
    }
)

' switch/case construct. usage looks like:
' c switch \
'     case: "{" do: { "foo" },
'     case: "}" do: { "blah" },
'     default: { "argh" }
Object prototype :: switch {
    ' ### bob: having to do this is lame. :(
    outerSelf <- self
    Switch prototype copyWith: {
        _value  <- outerSelf
        _done   <- False
        _result <- Nil
    }
}

Switch <- Object new: {
    _prototype <- Object new: {
        self :: case: case do: block {
            ' if this switch has already matched a case, just do nothing
            if: _done? not then: {
                ' if the case is a block, then it's a predicate so evaluate it, otherwise
                ' it's a value, so compare it to the value being switched
                matched <- if: case block? then: {
                    case call: _value
                } else: {
                    _value = case
                }

                if: matched then: {
                    ' execute the block
                    _result <- block call: _value
                    _done? <- True
                }
            }

            ' always return the result. if we haven't matched yet, this will
            ' just be Nil. once we've matched, it will be the matched value.
            _result
        }

        self :: default: block {
            ' if this switch has already matched a case, just do nothing
            if: _done? not then: {
                ' execute the block
                _result <- block call: _value
                _done? <- True
            }

            _result;
        }
    }

    self :: prototype { _prototype }
}


writeLine: "Base library loaded."

' ###bob: temp, run tests
load: "../../test/test.fin"
