' object
Object <- #PRIM# copy: objectPrototype

' access the object prototype object
Object :: prototype { #PRIM# objectPrototype }

Object prototype :: copy {
  #PRIM# copy: self
}

Object prototype :: copyWith: block {
  copy <- #PRIM# copy: self
  #PRIM# run: block within: copy
  copy
}

Object :: new {
    Object prototype copy
}

Object :: new: block {
    Object prototype copyWith: block
}

Object prototype :: != right {
    (self = right) not
}

' any non-true object is implicitly "false", so sending "not" to it
' returns true
Object prototype :: not { True }

' type tests
Object prototype :: array? { False }
Object prototype :: block? { False }
Object prototype :: boolean? { False }
Object prototype :: fiber? { False }
Object prototype :: number? { False }
Object prototype :: string? { False }

Object prototype :: ifTrue: then else: else { else call }

' calling a non-block like a block just returns the value
Object prototype :: call { self }
Object prototype :: call: a { self }
Object prototype :: call: a : b { self }
Object prototype :: call: a : b : c { self }
Object prototype :: call: a : b : c : d { self }
Object prototype :: call: a : b : c : d : e { self }
Object prototype :: call: a : b : c : d : e : f { self }
Object prototype :: call: a : b : c : d : e : f { self }
Object prototype :: call: a : b : c : d : e : f : g { self }
Object prototype :: call: a : b : c : d : e : f : g : h { self }
Object prototype :: call: a : b : c : d : e : f : g : h : i { self }
Object prototype :: call: a : b : c : d : e : f : g : h : i : j { self }


True :: not { False }

True :: boolean? { True }
False :: boolean? { True }

True :: toString { "true" }
False :: toString { "false" }

True :: ifTrue: then else: else { then call }

' define a for-style loop
Ether :: from: start to: end step: step do: block {
    i <- start
    
    while: { i <= end } do: {
        block call: i
        i <-- i + step
    }
}

Ether :: from: start to: end do: block {
    step <- (if: start < end then: 1 else: -1)
    from: start to: end step: step do: block
}

' do
Ether :: do: block {
    block call
}

' if then
Ether :: if: condition then: then {
    condition ifTrue: then else: { Nil }
}

Ether :: if: condition then: then else: else {
    condition ifTrue: then else: else
}

' a chained if/then/else
Ether :: if: if1 then: then1 elseif: if2 then: then2 else: else {
    if: if1 then: then1 else: {
        if: if2 then: then2 else: else
    }
}

' while
Ether :: while: condition do: block {
    ' set up a tail recursive block that evaluates the condition and does one
    ' pass through the loop before calling itself
    rec <- {
        if: condition call then: {
            block call
            rec call
        }
    }
    
    ' start the iteration
    rec call
}

' build the output methods in terms of the single primitive one
Ether :: write: text {
    ' make sure the argument is always converted to a string before
    ' passing to the primitive version which can't do that.
    #PRIM# write: text toString
}

Ether :: writeLine: text {
    ' make sure the argument is always converted to a string before
    ' passing to the primitive version which can't do that.
    #PRIM# write: text toString + "\n"
}

' block
Block <- Object new

Block :: prototype { #PRIM# blockPrototype }

Block prototype :: block? { True }

' fiber
Fiber <- Object new

Fiber :: new: block { #PRIM# newFiber: block }

Fiber :: spawn: block {
    fiber <- Fiber new: block
    ' immediately run it, discarding the first yielded result
    fiber run
    fiber
}

Fiber :: current { #PRIM# currentFiber }

Fiber :: yield: value {
  #PRIM# switchToFiber: Fiber current runBy passing: value
}

Fiber :: yield { Fiber yield: Nil }

Fiber :: prototype { #PRIM# fiberPrototype }

Fiber prototype :: fiber? { True }

Fiber prototype :: run: value {
  _runBy <- Fiber current
  #PRIM# switchToFiber: self passing: value
}

Fiber prototype :: run { self run: Nil }

Fiber prototype :: runBy { _runBy }

' number
Number <- Object new

Number :: prototype { #PRIM# numberPrototype }

Number prototype :: number? { True }

' string
String <- Object new

String :: prototype { #PRIM# stringPrototype }

String prototype :: string? { True }

String prototype :: + right {
    #PRIM# stringConcat: self toString and: right toString
}

String prototype :: = right {
    (#PRIM# stringCompare: self to: right) = 0
}

String prototype :: != right {
    (self = right) not
}

String prototype :: < right {
    (#PRIM# stringCompare: self to: right) < 0
}

String prototype :: > right {
    (#PRIM# stringCompare: self to: right) > 0
}

String prototype :: <= right {
    (#PRIM# stringCompare: self to: right) <= 0
}

String prototype :: >= right {
    (#PRIM# stringCompare: self to: right) >= 0
}

' array
Array <- Object new

Array :: prototype { #PRIM# arrayPrototype }

Array :: count: count {
    self count: count fillWith: Nil
}

Array :: count: count fillWith: element {
    result <- []
    
    from: 1 to: count do: {|i| result add: element }
    result
}

Array prototype :: array? { True }

Array prototype :: ++ right {
    result <- []
    
    self each: {|e| result add: e }
    right each: {|e| result add: e }
    
    result
}

Array prototype :: each: block {
    from: 0 to: self length - 1 do: {|i|
        block call: (self at: i)
    }
}

Array prototype :: map: block {
    result <- []
    self each: {|element| result add: (block call: element) }
    result
}

' truthiness: only two things are true: the True global object, and
' blocks that evaluate to it.
Object prototype :: true? { False }
True :: true? { True }

Block prototype :: true? { self call true? }

' logical operators

' by default, all objects are implicitly "false"
Object prototype :: and: right {
    if: self true? then: {
        right true?
    } else: {
        False
    }
}

Object prototype :: or: right {
    if: self true? then: {
        True
    } else: {
        right true?
    }
}

' switch/case construct. usage looks like:
' c switch \
'     case: "{" do: { "foo" },
'     case: "}" do: { "blah" },
'     default: { "argh" }
Object prototype :: switch {
    ' ### bob: having to do this is lame. :(
    outerSelf <- self
    Switch prototype copyWith: {
        _value  <- outerSelf
        _done   <- False
        _result <- Nil
    }
}

Switch <- Object new: {
    _prototype <- Object new: {
        self :: case: case do: block {
            ' if this switch has already matched a case, just do nothing 
            if: _done? not then: {
                ' if the case is a block, then it's a predicate so evaluate it, otherwise
                ' it's a value, so compare it to the value being switched
                matched <- if: case block? then: {
                    case call: _value
                } else: {
                    _value = case
                }

                if: matched then: {
                    ' execute the block
                    _result <- block call: _value
                    _done? <- True
                }
            }
            
            ' always return the result. if we haven't matched yet, this will
            ' just be Nil. once we've matched, it will be the matched value.
            _result
        }
        
        self :: default: block {
            ' if this switch has already matched a case, just do nothing 
            if: _done? not then: {
                ' execute the block
                _result <- block call: _value
                _done? <- True
            }
            
            _result;
        }
    }
    
    self :: prototype { _prototype }
}


writeLine: "Base library loaded."

' ###bob: temp, run tests
load: "../../test/test.fin"
