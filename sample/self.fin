' tests various edges regarding self

Nil addMethod: "name" body: { "Nil" }

Parent <- (||
    _name <- "parent"
    name { _name }

    getName { "parent" }
    calledName { self getName }

    recursiveName: depth {
        if: depth > 0 then: {
            _name + " " + (Parent recursiveName: 0) + " " +
            _name + " " + (Child recursiveName: 0) + " " +
            _name
        } else: { _name }
    }
)

Child <- (||
    _name <- "child"
    getName { "child" }
)

' basic just call a method on an object
writeLine: Parent name + " (expect: parent)"
writeLine: Parent calledName + " (expect: parent)"
writeLine: (Parent recursiveName: 1) + " (expect: parent parent parent child parent)"

' make sure calling an inherited method uses the child as self
writeLine: Child name + " (expect: child)"
writeLine: Child calledName + " (expect: child)"
writeLine: (Child recursiveName: 1) + " (expect: child parent child child child)"

Other <- (||
    name { "Other" }

    callMe: block { block call }
)

' passing a block to a method should *not* use the method's self
' in this case, since the block is not defined in any object, self
' should be nil
writeLine: (Other callMe: { self name }) + " (expect Nil)"

Foo <- (||
    name { "Foo" }

    routeThroughOther {
        Other callMe: { self name }
    }
)

' passing a block to a method should *not* use the method's self
' instead, should use the self where the block is declared. in this
' case, that's inside Foo
writeLine: Foo routeThroughOther + " (expect Foo)"

Child :: getBlock { { self name } }

' returning a block from a method should keep the block bound to the
' method's self
b <- Child getBlock
writeLine: b call + " (expect child)"
writeLine: (Other callMe: b) + " (expect child)"