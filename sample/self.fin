' tests various edges regarding self

Nil addMethod: "name" body: { "Nil" }

Parent <- Object copyWith: {
    _name <- "parent"
    self :: name { _name }
    
    self :: getName { "parent" }
    self :: calledName { self getName }
    
    self :: recursiveName: depth {
        if: depth > 0 then: {
            _name + " " + (Parent recursiveName: 0) + " " +
            _name + " " + (Child recursiveName: 0) + " " +
            _name
        } else: { _name }
    }
}

Child <- Parent copyWith: {
    _name <- "child"

    self :: getName { "child" }
}

' basic just call a method on an object
writeLine: Parent name + " (expect: parent)"
writeLine: Parent calledName + " (expect: parent)"
writeLine: (Parent recursiveName: 1) + " (expect: parent parent parent child parent)"

' make sure calling an inherited method uses the child as self
writeLine: Child name + " (expect: child)"
writeLine: Child calledName + " (expect: child)"
writeLine: (Child recursiveName: 1) + " (expect: child parent child child child)"

Other <- Object copyWith: {
    self :: name { "Other" }
    
    self :: callMe: block {
        block call
    }
}

' passing a block to a method should *not* use the method's self
' in this case, since the block is not defined in any object, self
' should be nil
writeLine: (Other callMe: { self name }) + " (expect Nil)"

Foo <- Object copyWith: {
    self :: name { "Foo" }
    
    self :: routeThroughOther {
        Other callMe: { self name }
    }
}

' passing a block to a method should *not* use the method's self
' instead, should use the self where the block is declared. in this
' case, that's inside Foo
writeLine: Foo routeThroughOther + " (expect Foo)"

Child :: getBlock { { self name } }

' returning a block from a method should keep the block bound to the
' method's self
b <- Child getBlock
writeLine: b call + " (expect child)"
writeLine: (Other callMe: b) + " (expect child)"