// tests various edges regarding self

def nil {
  name { "nil" }
}

obj Parent {
  _name = "parent"
  name { _name }

  get-name { "parent" }
  called-name { self.get-name }

  recursive-name(depth) {
    if (depth > 0) then {
      _name + " " + Parent.recursive-name(0) + " " +
      _name + " " + Child.recursive-name(0) + " " +
      _name
    } else { _name }
  }
}

obj Child -> Parent {
  _name = "child"
  get-name { "child" }
}

// basic just call a method on an object
print(Parent.name + " (expect: parent)")
print(Parent.called-name + " (expect: parent)")
print(Parent.recursive-name(1) +
    " (expect: parent parent parent child parent)")

// make sure calling an inherited method uses the child as self
print(Child.name + " (expect: child)")
print(Child.called-name + " (expect: child)")
print(Child.recursive-name(1) +
    " (expect: child parent child child child)")

obj Other {
  name { "Other" }
  call-me(block) { block.call }
}

// passing a block to a method should *not* use the method's self
// in this case, since the block is not defined in any object, self
// should be nil
print(Other.call-me { self.name } + " (expect nil)")

obj Foo {
  name { "Foo" }

  route-through-other {
    Other.call-me { self.name }
  }
}

// passing a block to a method should *not* use the method's self
// instead, should use the self where the block is declared. in this
// case, that's inside Foo
print(Foo.route-through-other + " (expect Foo)")

def Child {
  get-block { { self.name } }
}

// returning a block from a method should keep the block bound to the
// method's self
var b = Child.get-block
print(b.call + " (expect child)")
print(Other.call-me(b) + " (expect child)")
