<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>The Finch Programming Language: Expressions</title>
<link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Inconsolata|Reenie+Beanie">
<link rel="stylesheet" type="text/css" href="styles.css" />
<script src="jquery-1.3.2.min.js" type="text/javascript"></script>
</head>
<body id="top">
<div class="content">
<h1><a href="index.html">Finch:</a> Expressions</h1>
<p><span class="nav"><a href="index.html">Welcome</a> | Expressions</span></p>
<p>Expressions are the heart of any programming language&mdash; they're the building blocks for programs. Finch, like many functional languages but unlike most C-derived languages, does not have statements, only expressions. We'll go over the different kinds of expressions Finch supports, starting from the bottom up.</p>
<h2>Comments</h2>
<p>OK, technically comments aren't expressions, but here is as good a place as any to describe them. Comments start with a single quote and end at the end of the line:</p>
<div class="codehilite"><pre><span class="c1">&#39; this is a comment</span>
</pre></div>


<h2>Literals</h2>
<p>Finch currently supports two atomic types: numbers and strings. Numbers are double-precision floating point values, and strings are text. Finch doesn't support a lot of fancy formats for them yet, just the basic:</p>
<div class="codehilite"><pre><span class="mi">0</span>
<span class="mi">1234</span>
<span class="mf">-432.1</span>
<span class="s">&quot;a string&quot;</span>
<span class="s">&quot;another string&quot;</span>
<span class="s">&quot;supported escapes: </span><span class="se">\&quot;</span><span class="s"> </span><span class="se">\n</span><span class="s"> </span><span class="se">\\</span><span class="s">&quot;</span>
</pre></div>


<h2>Variables</h2>
<p>Variable names in Finch are more flexible than in most other languages. They must start with a letter or an underscore, but pretty much everything is fair game after that. All of these are valid variable names:</p>
<div class="codehilite"><pre><span class="n">foo</span>
<span class="vg">Bar</span>
<span class="n">this2</span>
<span class="n">andPunctuation@#$%^&amp;*-_=+&lt;&gt;/?!</span>
</pre></div>


<p>There are three kinds of variables in Finch: global, local, and object. Global variables start with a capital letter. Local variables start with a lowercase letter, and object variables start with an underscore:</p>
<div class="codehilite"><pre><span class="vg">Global</span>
<span class="n">local</span>
<span class="vi">_object</span>
</pre></div>


<h2>Messages</h2>
<p>What other languages refer to as "calling a function" or "invoking a method", Finch calls "sending a message." Sending a message to an object (and remember, everything is an object) invokes a method on that object. There are three flavors of message sends in Finch: unary, operator, and keyword.</p>
<h3>Unary Messages</h3>
<p>An unary message has a name but no arguments beyond the object receiving the message. You can send an unary message to an object by following the object with the name of the message:</p>
<div class="codehilite"><pre><span class="c1">&#39; send the &#39;length&#39; message to the string &quot;hi there&quot;</span>
<span class="s">&quot;hi there&quot;</span> <span class="n">length</span>
</pre></div>


<h3>Operators</h3>
<p>Any sequence of punctuation characters can be used to define an operator, but don't go too crazy. The goal here is not to make your code look like comic strip profanity:</p>
<div class="codehilite"><pre><span class="c1">&#39; valid punctuation characters</span>
<span class="ow">+</span> <span class="ow">-</span> <span class="ow">!</span> <span class="ow">@</span> <span class="ow">#</span> <span class="ow">$</span> <span class="ow">%</span> <span class="ow">^</span> <span class="ow">&amp;</span> <span class="ow">*</span> <span class="ow">=</span> <span class="ow">&lt;</span> <span class="ow">&gt;</span> <span class="ow">/</span> <span class="ow">?</span> <span class="ow">~</span>

<span class="c1">&#39; can also be combined</span>
<span class="ow">--</span> <span class="ow">?!</span> <span class="ow">---@</span> <span class="ow">&lt;=/=&gt;</span> <span class="ow">@*#%&amp;#$@&amp;!</span>
</pre></div>


<p>Finch has no built-in operators. An expression like:</p>
<div class="codehilite"><pre><span class="n">a</span> <span class="ow">+</span> <span class="n">b</span>
</pre></div>


<p>Means "send a <code>+</code> message to <code>a</code>, passing in <code>b</code> as an argument." All operators have the same precedence and associate from left to right. This is unlike most other languages with hard-coded precedence levels. Parentheses are your friends here.</p>
<div class="codehilite"><pre><span class="mi">1</span> <span class="ow">+</span> <span class="mi">2</span> <span class="ow">*</span> <span class="mi">3</span>   <span class="c1">&#39; evaluates to 9 in Finch</span>
<span class="mi">1</span> <span class="ow">+</span> <span class="p">(</span><span class="mi">2</span> <span class="ow">*</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">&#39; evaluates to 6</span>
</pre></div>


<p>Because there are no built-in operators, there are no unary operators in Finch. To negate an expression, instead of an unary <code>-</code> operator, send it the unary <code>neg</code> message:</p>
<div class="codehilite"><pre><span class="c1">&#39; NOT valid</span>
<span class="ow">-</span> <span class="n">someVar</span>

<span class="c1">&#39; OK!</span>
<span class="n">someVar</span> <span class="n">neg</span>
</pre></div>


<h3>Keyword Messages</h3>
<p>We've covered messages that take zero arguments (unary) and one (operators). To pass more than one argument, you use keyword messages. A keyword is a name followed by a colon (<code>:</code>), or just a colon by itself. A keyword message is formed by alternating keywords and arguments. An example will help here:</p>
<div class="codehilite"><pre><span class="n">dictionary</span> <span class="k">addKey:</span> <span class="s">&quot;some key&quot;</span> <span class="k">value:</span> <span class="s">&quot;the value&quot;</span>
</pre></div>


<p>This sends the <code>addKey:value:</code> message to the <code>dictionary</code> object, passing in "some key" and "the value" as arguments. You can chain as many keywords as you want in a single message (within reason):</p>
<div class="codehilite"><pre><span class="n">chef</span> <span class="k">prepareSoup:</span> <span class="n">tomato</span> <span class="k">appetizer:</span> <span class="n">calimari</span> <span class="k">entree:</span> <span class="n">veal</span> <span class="k">dessert:</span> <span class="n">cake</span>
</pre></div>


<p>That sends a <em>single</em> <code>prepareSoup:appetizer:entree:dessert:</code> message to <code>chef</code> with four arguments.</p>
<p>Like other messages, keyword messages usually follow a receiver (<code>dictionary</code> and <code>chef</code> in the above examples). However, you can also omit the receiver. In that case, it will implicitly be sent to a special <code>Ether</code> object:</p>
<div class="codehilite"><pre><span class="c1">&#39; this:</span>
<span class="k">write:</span> <span class="s">&quot;hi&quot;</span>
<span class="c1">&#39; is equivalent to:</span>
<span class="vg">Ether</span> <span class="k">write:</span> <span class="s">&quot;hi&quot;</span>
</pre></div>


<h2>Sequences</h2>
<p>Multiple expressions can be sequenced together into a single expression by separating them with newlines. This code:</p>
<div class="codehilite"><pre><span class="k">write:</span> <span class="s">&quot;hi&quot;</span>
<span class="k">write:</span> <span class="s">&quot;bye&quot;</span>
</pre></div>


<p>forms a single expression that writes two things. A sequence returns the value of the last expression. The returns of the other expressions are discarded.</p>
<p>If you want to sequence multiple expressions in a single line, you can also use a semicolon (<code>;</code>) as a separator:</p>
<div class="codehilite"><pre><span class="k">write:</span> <span class="s">&quot;hi&quot;</span><span class="o">;</span> <span class="k">write:</span> <span class="s">&quot;bye&quot;</span>
</pre></div>


<p>This generally implies that newlines are significant. However, there are some places they get ignored to make things easier on you. The rules are:</p>
<ol>
<li>
<p>Leading newlines at the top of a file are ignored.</p>
</li>
<li>
<p>Duplicate newlines get collapsed into one. (This means you can put blank lines wherever.)</p>
</li>
<li>
<p>Newlines that are obviously in the middle of an expression are ignored. This means that if a line ends with a keyword (like <code>foo:</code>), an operator (like <code>+</code>), <code>|</code>, <code>&lt;-</code>, <code>&lt;--</code>, <code>(</code>, <code>[</code> or <code>{</code>, the newline will be ignored.</p>
</li>
</ol>
<h2>Blocks</h2>
<p>Finch looks like a lot of other languages in that curly braces define local blocks:</p>
<div class="codehilite"><pre><span class="p">{</span>
    <span class="k">write:</span> <span class="s">&quot;inside a block&quot;</span>
<span class="p">}</span>
</pre></div>


<p>However, these blocks aren't what you think they are. When you enclose an expression in curly braces, you're actually creating a block <em>object</em>. A block object is essentially a closure or a local function. It's an object that contains a chunk of code and a lexical scope (i.e. its own set of local variables).</p>
<p>When you create a block, the code inside it isn't immediately executed. It's just packaged up into the block object. The above example won't actually print anything. To invoke the code inside a block, you send the block object a <code>call</code> message:</p>
<div class="codehilite"><pre><span class="p">{</span> <span class="k">write:</span> <span class="s">&quot;inside a block&quot;</span> <span class="p">}</span> <span class="n">call</span>
</pre></div>


<p>Now "inside a block" will be printed.</p>
<h3>Blocks are Objects</h3>
<p>It's important to realize that blocks really are just objects. They can be stored in variables, passed to methods, etc. In fact, Finch doesn't have any built-in flow control structures. Consider:</p>
<div class="codehilite"><pre><span class="k">if:</span> <span class="n">a</span> <span class="ow">&lt;</span> <span class="n">b</span> <span class="k">then:</span> <span class="p">{</span>
    <span class="k">write:</span> <span class="s">&quot;less&quot;</span>
<span class="p">}</span> <span class="k">else:</span> <span class="p">{</span>
    <span class="k">write:</span> <span class="s">&quot;greater&quot;</span>
<span class="p">}</span>
</pre></div>


<p>That looks like some built-in <code>if/then</code> construct. It isn't. What you're looking at is an <code>if:then:else:</code> keyword message being sent to <code>Ether</code>. The two blocks are arguments that are sent with the message. The implementation of that method looks at the first condition argument, and decides which of the two blocks to <code>call</code> based on that.</p>
<h3>Block Arguments</h3>
<p>Because blocks are basically functions, you can also pass arguments to them. If a block has arguments, they appear after the opening curly brace, surrounded by pipes (<code>|</code>):</p>
<div class="codehilite"><pre><span class="p">{</span><span class="kd">|</span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="kd">|</span> <span class="n">a</span> <span class="ow">+</span> <span class="n">b</span> <span class="p">}</span>
</pre></div>


<p>The above code creates a block that takes two arguments. When called, it returns the sum of the arguments. You pass arguments to a block by using one of the keyword versions of <code>call</code>. For example:</p>
<div class="codehilite"><pre><span class="p">{</span><span class="kd">|</span><span class="nv">a</span><span class="kd">|</span> <span class="k">write:</span> <span class="n">a</span> <span class="p">}</span> <span class="k">call:</span> <span class="s">&quot;arg&quot;</span> <span class="c1">&#39; one argument</span>
<span class="p">{</span><span class="kd">|</span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="kd">|</span> <span class="k">write:</span> <span class="n">a</span> <span class="ow">+</span> <span class="n">b</span> <span class="p">}</span> <span class="k">call:</span> <span class="s">&quot;one&quot;</span> <span class="err">:</span> <span class="s">&quot;two&quot;</span> <span class="c1">&#39; two args</span>
<span class="p">{</span><span class="kd">|</span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="nv">c</span><span class="kd">|</span> <span class="k">write:</span> <span class="n">a</span> <span class="ow">+</span> <span class="n">b</span> <span class="ow">+</span> <span class="n">c</span> <span class="p">}</span> <span class="k">call:</span> <span class="s">&quot;one&quot;</span> <span class="err">:</span> <span class="s">&quot;two&quot;</span> <span class="err">:</span> <span class="s">&quot;three&quot;</span> <span class="c1">&#39; you get the idea</span>
</pre></div>


<p>If you pass too many arguments to a block, the extra ones will be ignored. If you don't pass enough, it will assign the special value <code>Nil</code> to the missing ones.</p>
<h2>Assignment</h2>
<p>Variables are declared and given values using assignment expressions. An assignment expression is simply a name followed by an assignment arrow, followed by some expression for the value to assign to the variable. For example:</p>
<div class="codehilite"><pre><span class="n">a</span> <span class="o">&lt;-</span> <span class="s">&quot;some value&quot;</span>
</pre></div>


<p>Variables do not have to be explicitly declared&mdash; assigning it a value will create it if it doesn't already exist. The value returned by an assignment expression is the assigned value. For example:</p>
<div class="codehilite"><pre><span class="k">write:</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;-</span> <span class="s">&quot;hi&quot;</span><span class="p">)</span>
</pre></div>


<p>This creates a variable <code>a</code>, assigns "hi" to it, then prints "hi".</p>
<h3>Short and Long Assignment</h3>
<p>There are actually <em>two</em> kinds of assignment in Finch: short and long. The <code>&lt;-</code> operator is short assignment and is what you'll use most of the time. It assigns to a variable in the current scope. If you want to avoid creating a <em>new</em> variable in the current scope and instead assign to an existing variable defined in an outer scope, you use the long assignment arrow: <code>&lt;--</code>.</p>
<p>An example will clarify:</p>
<div class="codehilite"><pre><span class="n">a</span> <span class="o">&lt;-</span> <span class="s">&quot;outside&quot;</span>
<span class="k">do:</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">&lt;-</span> <span class="s">&quot;inside&quot;</span>
<span class="p">}</span>
<span class="k">write:</span> <span class="s">&quot;a&quot;</span>
</pre></div>


<p>This chunk of code will display "outside". The assignment inside the <code>do:</code> block creates a new <code>a</code> variable local to that block. When the block ends, that <code>a</code> is discarded and the outer one remains. Let's change it to use long assignment:</p>
<div class="codehilite"><pre><span class="n">a</span> <span class="o">&lt;-</span> <span class="s">&quot;outside&quot;</span>
<span class="k">do:</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">&lt;--</span> <span class="s">&quot;inside&quot;</span>
<span class="p">}</span>
<span class="k">write:</span> <span class="s">&quot;a&quot;</span>
</pre></div>


<p>Now this code will print "inside". The <code>a &lt;-- "inside"</code> line now means "walk up the scope chain looking for an <em>existing</em> variable named <code>a</code> and assign to it." (If it fails to find a previously declared variable to assign to, it just does nothing.)</p>
<p>One way you can think of this is that short assignment always means "declare a new variable in the current scope" and long assignment means "assign to an existing one."</p>
<h2>Arrays</h2>
<p>Finch has built-in support for resizable arrays. Most of the things you can do with arrays use normal message syntax, but there's also a little special sauce for creating arrays. If you surround a series of expressions with square brackets, it creates an array with an element for the value of each expression. Elements are separated with newlines or semi-colons like in a regular sequence. Enough talk:</p>
<div class="codehilite"><pre><span class="p">[]</span>             <span class="c1">&#39; creates an empty array</span>
<span class="p">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="p">]</span>      <span class="c1">&#39; a three-element array</span>
<span class="p">[</span><span class="mi">123</span><span class="o">;</span> <span class="s">&quot;text&quot;</span><span class="p">]</span>  <span class="c1">&#39; arrays can have elements of different types</span>
<span class="p">[</span><span class="mi">1</span> <span class="ow">+</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span> <span class="n">neg</span><span class="p">]</span> <span class="c1">&#39; expressions are fine too</span>

<span class="c1">&#39; newlines can separate elements too</span>
<span class="p">[</span><span class="s">&quot;first&quot;</span>
 <span class="s">&quot;second&quot;</span>
 <span class="s">&quot;third&quot;</span><span class="p">]</span>
</pre></div>


<p>Arrays are objects like everything else, so they can be stored in variables, passed to methods, etc.</p>
<h2>Combining Expressions: Precedence and Associativity</h2>
<p>OK, so we've got the building blocks. Now let's talk about how they interact. The two keys parts are precedence and associativity. Precedence determines which expression binds "tighter" when different expression types are mixed together. From lowest (loosest) to highest, we have: sequences, assignment, keyword messages, operators, then unary messages. For example, given an expression like this:</p>
<div class="codehilite"><pre><span class="n">a</span> <span class="o">&lt;-</span> <span class="mi">8</span> <span class="ow">+</span> <span class="mi">2</span> <span class="n">neg</span> <span class="k">mod:</span> <span class="mi">4</span> <span class="ow">-</span> <span class="mi">2</span>
<span class="k">write:</span> <span class="n">a</span>
</pre></div>


<p>Finch will parse that like this:</p>
<div class="codehilite"><pre><span class="p">((</span><span class="n">a</span> <span class="o">&lt;-</span> <span class="p">((</span><span class="mi">8</span> <span class="ow">+</span> <span class="p">(</span><span class="mi">2</span> <span class="n">neg</span><span class="p">))</span> <span class="k">mod:</span> <span class="p">(</span><span class="mi">4</span> <span class="ow">-</span> <span class="mi">2</span><span class="p">)))</span><span class="o">;</span> <span class="p">(</span><span class="k">write:</span> <span class="n">a</span><span class="p">))</span>
</pre></div>


<p>Associativity controls how a series of the same type of expression is interpreted. Unary and operator messages associate to the left. A series of keywords will be parsed into a single keyword. Assignment is right-associative. Or, by example:</p>
<div class="codehilite"><pre><span class="mi">3</span> <span class="n">neg</span> <span class="n">abs</span> <span class="n">square</span>            <span class="c1">&#39; is parsed as (((3 neg) abs) square)</span>
<span class="mi">1</span> <span class="ow">+</span> <span class="mi">2</span> <span class="ow">*</span> <span class="mi">3</span> <span class="ow">-</span> <span class="mi">4</span>               <span class="c1">&#39; is parsed as (((1 + 2) * 3) - 4)</span>
<span class="n">dict</span> <span class="k">addKey:</span> <span class="mi">123</span> <span class="k">value:</span> <span class="s">&quot;v&quot;</span> <span class="c1">&#39; is parsed as a single &quot;addKey:value:&quot; message</span>
<span class="n">a</span> <span class="o">&lt;-</span> <span class="n">b</span> <span class="o">&lt;-</span> <span class="n">c</span> <span class="o">&lt;-</span> <span class="mi">4</span>            <span class="c1">&#39; is parsed as (a &lt;- (b &lt;- (c &lt;- 4)))</span>
</pre></div>


<p>That's pretty much the entirety of Finch's syntax. It's different, but I think it's a good bit simpler than most languages out there. (I'm looking at you C++.)</p><p class="footer">Last modified on July 01, 2010 | email = robert, domain = stuffwithstuff.com</p>
</div>
</body>
</html>