// symbols:
`symbolName

// blocks:
{ obj someMessage }
{|arg| someMessage }
{|| it someMessage } // implicit arg name "it"
{|first second| first gets: second }

// compound expressions:
obj first; obj second

// early return:
return resultObject

// cascade:
foo bar, bang, baz // same as foo bar; foo bang; foo baz

// define data slot (basically creates set and get messages):
someObj add-field: `fieldName
someObj add-field: `fieldName value: 1234

// define methods:
someObj add-method: `message-name block: { self do-something }
someObj add-method: `+some-op block: {|rhs| self do-something }
someObj add-method: `key:word:method: block: {|a b c| self do-something }

// define prototype slot:
someObj prototype: thePrototype

// set data slot:
someObj slotName: 123 // not the same as defining a slot

// get data slot:
someObj slotName

// local variables:
def temp 123 // defines a new local at this scope

set temp 123 // sets the value of 'temp' at whatever scope it was
             // previously defined. use this to change variables
             // defined in outer scopes
             
unset temp // remove a previously defined variable at this scope
// note this is different from setting temp to Nil
// when you unset a variable, you unshadow that name
// from being accessible in a parent scope. consider:
{
    def a 1
    
    // set to nil
    {
        def a 2
        set a Nil
        Out write: a // writes 'nil'
    }
    
    // unset
    {
        def a 2
        unset a
        Out write: a // writes 1
    }
}

// global variables:
def SomeGlobal // case distinguishes global from local
